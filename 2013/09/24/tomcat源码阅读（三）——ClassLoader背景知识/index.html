<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本系列是阅读tomcat源码的总结。本文介绍classloader的背景知识，tomcat用到很多ClassLoader相关的代码，如果缺乏这方面的背景知识，阅读源码会遇到很多障碍，所以本文首先总结一下这方面的内容，和tomcat源码的关系不大">
<meta property="og:type" content="article">
<meta property="og:title" content="tomcat源码阅读（三）——ClassLoader背景知识">
<meta property="og:url" content="http://yoursite.com/2013/09/24/tomcat源码阅读（三）——ClassLoader背景知识/index.html">
<meta property="og:site_name" content="xqhu&#39;s blog">
<meta property="og:description" content="本系列是阅读tomcat源码的总结。本文介绍classloader的背景知识，tomcat用到很多ClassLoader相关的代码，如果缺乏这方面的背景知识，阅读源码会遇到很多障碍，所以本文首先总结一下这方面的内容，和tomcat源码的关系不大">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://dl2.iteye.com/upload/attachment/0086/6318/cda2bded-7c0d-372b-907a-330b86416867.png">
<meta property="og:image" content="http://dl2.iteye.com/upload/attachment/0086/6328/633a03a6-f4aa-3e54-956e-591987666ca2.png">
<meta property="og:image" content="http://dl2.iteye.com/upload/attachment/0086/6332/3540c9de-14cc-3dc5-a38e-18c65b50eb9b.png">
<meta property="og:image" content="http://dl2.iteye.com/upload/attachment/0086/6334/740a9cca-6bcb-31fc-885a-828e2f814016.png">
<meta property="og:image" content="http://dl2.iteye.com/upload/attachment/0086/6341/6665a02e-213a-3d92-9ef0-29f29ed49f46.png">
<meta property="og:updated_time" content="2018-06-17T13:23:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tomcat源码阅读（三）——ClassLoader背景知识">
<meta name="twitter:description" content="本系列是阅读tomcat源码的总结。本文介绍classloader的背景知识，tomcat用到很多ClassLoader相关的代码，如果缺乏这方面的背景知识，阅读源码会遇到很多障碍，所以本文首先总结一下这方面的内容，和tomcat源码的关系不大">
<meta name="twitter:image" content="http://dl2.iteye.com/upload/attachment/0086/6318/cda2bded-7c0d-372b-907a-330b86416867.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2013/09/24/tomcat源码阅读（三）——ClassLoader背景知识/"/>





  <title>tomcat源码阅读（三）——ClassLoader背景知识 | xqhu's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xqhu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/09/24/tomcat源码阅读（三）——ClassLoader背景知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xqhu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xqhu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">tomcat源码阅读（三）——ClassLoader背景知识</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-09-24T11:25:00+09:00">
                2013-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本系列是阅读tomcat源码的总结。本文介绍classloader的背景知识，tomcat用到很多ClassLoader相关的代码，如果缺乏这方面的背景知识，阅读源码会遇到很多障碍，所以本文首先总结一下这方面的内容，和tomcat源码的关系不大<br><a id="more"></a></p>
<h1 id="标准的ClassLoader体系"><a href="#标准的ClassLoader体系" class="headerlink" title="标准的ClassLoader体系"></a>标准的ClassLoader体系</h1><p><img src="http://dl2.iteye.com/upload/attachment/0086/6318/cda2bded-7c0d-372b-907a-330b86416867.png" alt=""></p>
<h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><p>bootstrap classloader是由JVM启动的，用于加载%JAVA_HOME%/jre/lib/下的JAVA平台自身的类（比如rt.jar中的类等）。这个classloader位于JAVA类加载器链的顶端，是用C/C++开发的，而且JAVA应用中没有任何途径可以获取到这个实例，它是JDK实现的一部分 </p>
<h2 id="extension"><a href="#extension" class="headerlink" title="extension"></a>extension</h2><p>entension classloader用于加载%JAVA_HOME%/jre/lib/ext/下的类，它的实现类是sun.misc.Launcher$ExtClassLoader，是一个内部类 </p>
<p>基本上，我们开发的JAVA应用都不太需要关注这个类 </p>
<h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>system classloader是jvm启动时，根据classpath参数创建的类加载器（如果没有显式指定classpath，则以当前目录作为classpath）。在普通的JAVA应用中，它是最重要的类加载器，因为我们写的所有类，通常都是由它加载的。这个类加载器的实现类是sun.misc.Launch$AppClassLoader </p>
<p>用ClassLoader.getSystemClassLoader()，可以得到这个类加载器 </p>
<h2 id="custom"><a href="#custom" class="headerlink" title="custom"></a>custom</h2><p>一般情况下，对于普通的JAVA应用，ClassLoader体系就到system为止了。平时编程时，甚至都不会感受到classloader的存在 </p>
<p>但是对于其他一些应用，比如web server，插件加载器等，就必须和ClassLoader打交道了。这时候默认的类加载器不能满足需求了（类隔离、运行时加载等需求），需要自定义类加载器，并挂载到ClassLoader链中（默认会挂载到system classloader下面） </p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>从上面的图可以看到，classloader链，是一个自上而下的树形结构。一般来说，java中的类加载，是遵循双亲委派模型的，即： 当一个classloader要加载一个类时，首先会委托给它的parent classloader来加载，如果parent找不到，才会自己加载。如果最后也找不到，则会抛出熟悉的ClassNotFoundException </p>
<p>这个模型，是在最基础的抽象类ClassLoader里确定的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">	throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">	// First, check if the class has already been loaded</span><br><span class="line">	Class c = findLoadedClass(name);</span><br><span class="line">	if (c == null) &#123;</span><br><span class="line">	    try &#123;</span><br><span class="line">		if (parent != null) &#123;</span><br><span class="line">		    c = parent.loadClass(name, false);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		    c = findBootstrapClassOrNull(name);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">	        // If still not found, then invoke findClass in order</span><br><span class="line">	        // to find the class.</span><br><span class="line">	        c = findClass(name);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (resolve) &#123;</span><br><span class="line">	    resolveClass(c);</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>自定义ClassLoader的时候，一般来说，需要做的并不是覆盖loadClass()方法，这样的话就“破坏”了双亲委派模型；需要做的只是实现findClass()方法即可 </p>
<p>不过，从上面的代码也可以看出，双亲委派模型只是一种“建议”，并没有强制保障的措施。如果自定义的ClassLoader无视此规定，直接自行加载，不将请求委托给parent，当然也是没问题的 </p>
<p>在实际情况中，双亲委派模型被“破坏”也是很常见的。比如在tomcat里，webappx classloader就不会委托给上层的common classloader，而是先委托给system，然后自己加载，最后才委托给common；再比如说在OSGi里，更是有意完全打破了这个规则 </p>
<p>当然，对于普通的JAVA应用开发来说，需要自定义classloader的场景本来就不多，需要去违反双亲委派模型的场景，更是少之又少 </p>
<h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p>在某些情况下，我们也需要自定义ClassLoader</p>
<h2 id="自定义ClassLoader的一般做法"><a href="#自定义ClassLoader的一般做法" class="headerlink" title="自定义ClassLoader的一般做法"></a>自定义ClassLoader的一般做法</h2><p>从上面的代码可以看到，自定义ClassLoader很简单，只要继承抽象类ClassLoader，再实现findClass()方法就可以了 </p>
<h2 id="自定义ClassLoader的场景"><a href="#自定义ClassLoader的场景" class="headerlink" title="自定义ClassLoader的场景"></a>自定义ClassLoader的场景</h2><p>事实上，需要实现新的ClassLoader的场景是很少的 </p>
<p>注意：需要增加一个自定义ClassLoader的场景很多；但是，需要自己实现一个新的ClassLoader子类的场景不多。这是两回事，不可混淆 </p>
<p>比如，即使在tomcat里，也没有自行实现新的ClassLoader子类，只是创建了URLClassLoader的实例，作为custom classloader </p>
<h2 id="ClassLoader的子类"><a href="#ClassLoader的子类" class="headerlink" title="ClassLoader的子类"></a>ClassLoader的子类</h2><p>在JDK中已经提供了若干ClassLoader的子类，在需要的时候，可以直接创建实例并使用。其中最常用的是URLClassLoader，用于读取一个URL下的资源，从中加载Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public class StandardClassLoader</span><br><span class="line">    extends URLClassLoader</span><br><span class="line">    implements StandardClassLoaderMBean &#123;</span><br><span class="line"></span><br><span class="line">    public StandardClassLoader(URL repositories[]) &#123;</span><br><span class="line">        super(repositories);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StandardClassLoader(URL repositories[], ClassLoader parent) &#123;</span><br><span class="line">        super(repositories, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，tomcat就是在URLClassLoader的基础上，包装了StandardClassLoader，实际上并没有任何功能上的区别 </p>
<h2 id="设置parent"><a href="#设置parent" class="headerlink" title="设置parent"></a>设置parent</h2><p>在抽象类ClassLoader中定义了一个parent字段，保存的是父加载器。但是这个字段是private的，并且没有setter方法 这就意味着只能在构造方法中，一次性地设置parent classloader。如果没有设置的话，则会默认将system classloader设置为parent，这也是在ClassLoader类中确定的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected ClassLoader(ClassLoader parent) &#123;</span><br><span class="line">        this(checkCreateClassLoader(), parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected ClassLoader() &#123;</span><br><span class="line">        this(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ClassLoader隐性传递"><a href="#ClassLoader隐性传递" class="headerlink" title="ClassLoader隐性传递"></a>ClassLoader隐性传递</h1><p>“隐性传递”这个词是我乱造的，在网上和注释中没有找到合适的描述的词 </p>
<p>试想这样一种场景：在应用中需要加载100个类，其中70个在classpath下，默认由system来加载，这部分不需要额外处理；另外30个类，由自定义classloader加载，比如在tomcat里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);</span><br><span class="line">Object startupInstance = startupClass.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>如上，org.apache.catalina.startup.Catalina是由自定义类加载器加载的，需要额外编程来处理（如果是system加载的，直接new就可以了） </p>
<p>如果30个类，都要通过这种方式来加载，就太麻烦了。不过classloader有一个特性，就是“隐性传递”，即： 如果一个ClassA是由某个ClassLoader加载的，那么ClassA中依赖的需要加载的类，默认也会由同一个ClassLoader加载 </p>
<p>这个机制是由JVM保证的，对于程序员来说是透明的 </p>
<h1 id="current-classloader"><a href="#current-classloader" class="headerlink" title="current classloader"></a>current classloader</h1><p>current classloader是一个很重要的概念</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>与前面说的extension、system等不同，在运行时并不存在一个实际的“current classloader”，只是一个抽象的概念。指的是一个类“当前的”类加载器。一个对象实例所属的Class，是由哪一个ClassLoader加载的，这个ClassLoader就是这个对象实例的current classloader </p>
<p>获得的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.getClass().getClassLoader();</span><br></pre></td></tr></table></figure></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>current classloader概念的意义，主要在于它会影响Class.forName()方法的表现，贴一段代码进行说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public void tryForName() &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;current classloader: &quot;</span><br><span class="line">				+ this.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;net.kyfxbl.test.cl.Target&quot;);</span><br><span class="line">                        System.out.println(&quot;load class success&quot;);</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类调用了Class.forName()方法，试图加载net.kyfxbl.test.cl.Target类（Target是一个空类，作为加载目标，不重要）。这个类在运行时能否加载Target成功，取决于它的current classloader，能不能加载到Target </p>
<p>首先，将Test和Target打成jar包，放到classpath之外，jar包中内容如下： </p>
<p><img src="http://dl2.iteye.com/upload/attachment/0086/6328/633a03a6-f4aa-3e54-956e-591987666ca2.png" alt=""></p>
<p>然后在工程中删除Target类（classpath中加载不到Target了） </p>
<p>在Main中用system 加载Test，此时Test的current classloader是system，加载Target类失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Test t = new Test();</span><br><span class="line">		t.tryForName();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，这次用自定义的classloader来加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		ClassLoader cl = createClassLoader();</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; startupClass = cl.loadClass(&quot;net.kyfxbl.test.cl.Test&quot;);</span><br><span class="line">		Object startupInstance = startupClass.newInstance();</span><br><span class="line"></span><br><span class="line">		String methodName = &quot;tryForName&quot;;</span><br><span class="line">		Class&lt;?&gt;[] paramTypes = new Class[0];</span><br><span class="line">		Object[] paramValues = new Object[0];</span><br><span class="line">		Method method = startupInstance.getClass().getMethod(methodName,</span><br><span class="line">				paramTypes);</span><br><span class="line">		method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static ClassLoader createClassLoader() throws MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">		String filePath = &quot;c://hehe.jar&quot;;</span><br><span class="line">		File file = new File(filePath);</span><br><span class="line">		URL url = file.toURI().toURL();</span><br><span class="line">		URL[] urls = new URL[] &#123; url &#125;;</span><br><span class="line">		ClassLoader myClassLoader = new URLClassLoader(urls);</span><br><span class="line">		return myClassLoader;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在想象中，这次Test的current classloader应该变成URLClassLoader，并且加载Target成功。但是还是失败了 </p>
<p>这是因为前面说过的“双亲委派模型”，URLClassLoader的parent是system classloader，由于工程里的Test类没有删除，所以classpath里还是能找到Test类，所以Test类的current classloader依然是system classloader，和第一次一样 </p>
<p><img src="http://dl2.iteye.com/upload/attachment/0086/6332/3540c9de-14cc-3dc5-a38e-18c65b50eb9b.png" alt=""></p>
<p>接下来把工程里的Test类也删除，这次就成功了 </p>
<p><img src="http://dl2.iteye.com/upload/attachment/0086/6334/740a9cca-6bcb-31fc-885a-828e2f814016.png" alt=""></p>
<h2 id="关于Class-forName"><a href="#关于Class-forName" class="headerlink" title="关于Class.forName()"></a>关于Class.forName()</h2><p>前面说的是单个参数的forName()方法，默认使用current ClassLoader 除此之外，Class类还定义了3个参数的forName()方法，方法签名如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String name, boolean initialize,</span><br><span class="line">				   ClassLoader loader)</span><br><span class="line">        throws ClassNotFoundException</span><br></pre></td></tr></table></figure></p>
<p>这个方法的最后一个参数，可以传递一个ClassLoader，会用这个ClassLoader进行加载。这个方法很重要 </p>
<p>比如像JNDI，主体类是在JDK包里，由bootstrap加载。而SPI的实现类，则是由厂商提供，一般在classpath里。那么在JNDI的主体类里，要加载SPI的实现类，直接用Class.forName()方法肯定是不行的，这时候就要用到3个参数的Class.forName()方法了 </p>
<h1 id="ContextClassLoader"><a href="#ContextClassLoader" class="headerlink" title="ContextClassLoader"></a>ContextClassLoader</h1><p>另一个重要的概念是ContextClassLoader</p>
<h2 id="获取ClassLoader的API"><a href="#获取ClassLoader的API" class="headerlink" title="获取ClassLoader的API"></a>获取ClassLoader的API</h2><p>前面说过，已经有2种方式可以获取到ClassLoader的引用 </p>
<p>一种是ClassLoader.getSystemClassLoader()，获取的是system classloader </p>
<p>另一种是getClass().getClassLoader()，获取的是current classloader </p>
<p>这2种API都只能获取classloader，没有办法用来传递 </p>
<h2 id="传递ClassLoader"><a href="#传递ClassLoader" class="headerlink" title="传递ClassLoader"></a>传递ClassLoader</h2><p>每一个thread，都有一个contextClassLoader，并且有getter和setter方法，用来在线程之间传递ClassLoader </p>
<p>有2条默认的规则： 首先，contextClassLoader默认是继承的，在父线程中创建子线程，那么子线程会继承父线程的contextClassLoader </p>
<p>其次，主线程，也就是执行main()方法的那个线程，默认的contextClassLoader是system classloader </p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>对上面例子中的Test和Main稍微改一下（Test和Target依然打到jar包里，然后从工程中删除，避免被system classloader加载到）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public void tryForName() &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;current classloader: &quot;</span><br><span class="line">				+ getClass().getClassLoader());</span><br><span class="line">		System.out.println(&quot;thread context classloader: &quot;</span><br><span class="line">				+ Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;net.kyfxbl.test.cl.Target&quot;);</span><br><span class="line">			System.out.println(&quot;load class success&quot;);</span><br><span class="line">		&#125; catch (Exception exc) &#123;</span><br><span class="line">			exc.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		ClassLoader cl = createClassLoader();</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; startupClass = cl.loadClass(&quot;net.kyfxbl.test.cl.Test&quot;);</span><br><span class="line">		final Object startupInstance = startupClass.newInstance();</span><br><span class="line"></span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				String methodName = &quot;tryForName&quot;;</span><br><span class="line">				Class&lt;?&gt;[] paramTypes = new Class[0];</span><br><span class="line">				Object[] paramValues = new Object[0];</span><br><span class="line">				try &#123;</span><br><span class="line">					Method method = startupInstance.getClass().getMethod(</span><br><span class="line">							methodName, paramTypes);</span><br><span class="line">					method.invoke(startupInstance, paramValues);</span><br><span class="line">				&#125; catch (Exception exc) &#123;</span><br><span class="line">					exc.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这次的tryForName()方法在一个子线程中被调用，并依次打印出current classloader和contextClassLoader，如图：<br><img src="http://dl2.iteye.com/upload/attachment/0086/6341/6665a02e-213a-3d92-9ef0-29f29ed49f46.png" alt=""></p>
<p>可以看到，子线程继承了父线程的contextClassLoader </p>
<p>同时可以注意到，contextClassLoader对Class.forName()方法没有影响，contextClassLoader只是起到在线程之间传递ClassLoader的作用 </p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>从这个例子还可以看出，一个方法在运行时的表现，在编译期是无法确定的 </p>
<p>在运行时的表现，有时候取决于方法所在的类是被哪个ClassLoader加载；有时候取决于是运行在单线程环境下，还是多线程环境下 </p>
<p>这在编译期是不可知的，所以在编程的时候，要考虑运行时的情况。比如所谓“线程安全”的类，并不是说它“一定”会运行在多线程环境下，而是说它“可以”运行在多线程环境下 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大致总结了ClassLoader的背景知识。掌握了背景，再阅读tomcat的源码，基本就不会遇到ClassLoader方面的困难 </p>
<p>本文介绍了ClassLoader的标准体系、双亲委派模型、自定义ClassLoader的方法、以及current classloader和contextClassLoader的概念。其中最重要的是current classloader和contextClassLoader </p>
<p>用于获取ClassLoader的API主要有3种： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader(); </span><br><span class="line">Class.getClassLoader(); </span><br><span class="line">Thread.getContextClassLoader();</span><br></pre></td></tr></table></figure>
<p>第一个是静态方法，返回的永远是system classloader，也就是说，没什么用 </p>
<p>后面2个都是实例方法，一个是返回实例所属的类的ClassLoader；另一个返回当前线程的contextClassLoader，具体的结果都要在运行时才能确定 </p>
<p>其中，contextClassLoader可以起到传递ClassLoader的作用，所以特别重要</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2013/09/24/Base64/" rel="next" title="Base64">
                <i class="fa fa-chevron-left"></i> Base64
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2013/09/24/关于系统集成的一些想法/" rel="prev" title="关于系统集成的一些想法">
                关于系统集成的一些想法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xqhu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">264</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#标准的ClassLoader体系"><span class="nav-number">1.</span> <span class="nav-text">标准的ClassLoader体系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bootstrap"><span class="nav-number">1.1.</span> <span class="nav-text">bootstrap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extension"><span class="nav-number">1.2.</span> <span class="nav-text">extension</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#system"><span class="nav-number">1.3.</span> <span class="nav-text">system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#custom"><span class="nav-number">1.4.</span> <span class="nav-text">custom</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">2.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义ClassLoader"><span class="nav-number">3.</span> <span class="nav-text">自定义ClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义ClassLoader的一般做法"><span class="nav-number">3.1.</span> <span class="nav-text">自定义ClassLoader的一般做法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义ClassLoader的场景"><span class="nav-number">3.2.</span> <span class="nav-text">自定义ClassLoader的场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClassLoader的子类"><span class="nav-number">3.3.</span> <span class="nav-text">ClassLoader的子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置parent"><span class="nav-number">3.4.</span> <span class="nav-text">设置parent</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ClassLoader隐性传递"><span class="nav-number">4.</span> <span class="nav-text">ClassLoader隐性传递</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#current-classloader"><span class="nav-number">5.</span> <span class="nav-text">current classloader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例"><span class="nav-number">5.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Class-forName"><span class="nav-number">5.3.</span> <span class="nav-text">关于Class.forName()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ContextClassLoader"><span class="nav-number">6.</span> <span class="nav-text">ContextClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取ClassLoader的API"><span class="nav-number">6.1.</span> <span class="nav-text">获取ClassLoader的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传递ClassLoader"><span class="nav-number">6.2.</span> <span class="nav-text">传递ClassLoader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子"><span class="nav-number">6.3.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题外话"><span class="nav-number">6.4.</span> <span class="nav-text">题外话</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xqhu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
